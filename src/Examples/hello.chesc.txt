chestnut

group   const
    #0  System.Console.println

group   Examples.Hello.main
    llset   $0  "Hello, World"
    lspush  $0
    call    #0
    return  void



group

    命令の集まりをグループとして分割します。

    const

        関数や定数などの、基本的に変更のない要素を定義します。

    [関数名]

        関数を定義します。

nadd

    1.スタックのトップにある２つの数字をポップする
    2.スタックにそれらの数字の演算結果をプッシュする

    スタックのトップにある２つの数字を加算します。
    スタックのトップの２つの数字はポップされ、演算結果がプッシュされます。

nsub

    1.スタックのトップにある２つの数字をポップする
    2.スタックにそれらの数字の演算結果をプッシュする

    スタックのトップにある２つの数字を減算します。
    スタックのトップの２つの数字はポップされ、演算結果がプッシュされます。

nmul

    1.スタックのトップにある２つの数字をポップする
    2.スタックにそれらの数字の演算結果をプッシュする

    スタックのトップにある２つの数字を乗算します。
    スタックのトップの２つの数字はポップされ、演算結果がプッシュされます。

ndiv

    1.スタックのトップにある２つの数字をポップする
    2.スタックにそれらの数字の演算結果をプッシュする

    スタックのトップにある２つの数字を除算します。
    スタックのトップの２つの数字はポップされ、演算結果がプッシュされます。

land

lor

call [関数番号]

    関数を呼び出します。
    ローカル要素を作成します。
    ローカルリストには最初から呼び出し時の引数が格納されます。

return [戻り値]

    戻り値を返して関数の処理を終了します。
    関数スタックを１回ポップします。
    ローカルスタックに戻り値をプッシュします。

llset [番号] [値]

    ローカルリストに値を設定します。

lspush [値]

    ローカルスタックに値をプッシュします。



< スレッドスタック >

    スレッドスタックは関数スタックを保持します。
    スレッド作成ごとにプッシュ、破棄時にポップされます。

< 関数スタック >

    関数スタックはローカル要素を保持します。
    関数呼び出しごとにプッシュ、return時にポップされます。

< ローカル要素 >

    ローカル要素はローカルスタックとローカルリストを保持します。
    関数スタックへのプッシュごとに作成、ポップ時に破棄されます。

< ローカルスタック >

    ローカルスタックは引数や演算結果などのスタック保持に適したデータを保持します。
    関数呼び出し毎にスタックが作成されます。

< ローカルリスト >

    ローカルリストはローカル変数などのリスト保持に適したデータを保持します。
    関数呼び出し毎にリストが作成されます。

< 関数呼び出し >

    1.spush命令でスタックに引数をプッシュ
    2.call命令で関数を呼ぶ

    call命令により引数の長さ分だけスタックがポップされます。
    呼び出し先の関数内でreturn命令を出すことで、呼び出し元の関数のスタックに戻り値がプッシュされます。



chestnut_compiled ; マジックナンバー
deffunc 2 9 Examples.Hello.main ; main関数の場所を2~9と定義
alloc   $0 $arg:0 ; 引数0を移動
free    $arg
alloc   $1 0 ; ループ条件用の変数領域を確保
alloc   $2 $1<100
if      $2
goto    8
alloc   
call System.Console.println


main(str[] args)
  for(100)
    println("Hello, " ~ args[0])


[関数定義]
main(str[] args)
↓
label   Example.main
alloc   $0 $arg:0
alloc   $1 $arg:1
...
free    $0
free    $1


[変数定義/初期化]
int hoge1
str hoge2 = "Example"
↓
alloc $0
alloc $0 "Example"


[メモリ解放]
free $0


[条件分岐]
if "hoge1" == "hoge2"
  //処理
↓
alloc $0 "hoge1"=="hoge2"
ifnot $0
goto 4
; 処理



chestnut_compiled
label   Examples.Hello.main ; 関数定義(label)
alloc   $0 $arg:0 ; 引数0を移動
free    $arg ; 引数を解放
alloc   $1 0 ; ループカウント用の変数を確保
alloc   $2 0<100 ; ループ条件用の変数を確保
if      $2 0 ; ループ条件用の変数を確保
goto    14
end
alloc   $arg:0 "Hello, "~$0:0~"!"
call    System.Console.println
alloc   $1 $0+1
alloc   $2 0<100 ; ループ条件用のフラグを更新
goto    7
